
# 一、Java基础

## 前言

学习Java需要掌握的基本概念和技能

1. Java基础语法：基础语法包括：变量、数据类型、运算符、控制结构等
2. 面向对象编程：掌握面向对象编程思想，包括：类和对象、封装、继承、多态。
3. Java API：了解Java api的基本使用，熟悉常用类库和方法的功能和用法。
4. 数据库基础：SQL语言，了解数据库的基本概念和操作
5. web技术：掌握HTML、css、JavaScript等前段技术，了解web开发的基本流程和技术架构，熟悉常用的web框架，如spring、mvc，Struts等。
6. Java并发编程：掌握Java并发编程的基本概念和技术，包括：线程、同步、锁等。
7. 工具使用：熟悉Eclipse、IDEA等开发工具，了解Maven、Git等常用开发工具和版本控制工具。
8. 项目实践：通过项目实践，了解项目开发全过程，包括需求分析、设计、编码、测试、部署等。

## 应届生

- Java基础知识：掌握Java的语法、面向对象编程、集合框架、异常处理等基础知识，熟悉Java的运行机制和开发工具。

- 数据库：熟练掌握关系型数据库MySQL的基础操作和SQL语言的使用，了解常用的数据库设计原则和优化方法，熟悉至少一种ORM框架（如MyBatis、Hibernate等）的使用。

- Web开发技术：掌握HTML、CSS、JavaScript等前端技术，熟悉前后端分离的开发模式，了解至少一种Web框架（如Spring、Spring MVC、Struts2等）的使用。

- 数据结构与算法：了解基本的数据结构和算法，如数组、链表、栈、队列、二叉树、排序算法等，能够运用它们解决实际问题。

- 设计模式：了解常用的设计模式，如单例模式、工厂模式、观察者模式等，能够在开发中灵活运用。

- 版本控制：熟悉至少一种版本控制工具（如Git、SVN等）的使用，能够进行代码的管理和协同开发。

- 其他技能：了解常用的项目管理工具（如Maven、Gradle等）、测试框架（如JUnit、Mockito等）、Linux系统基本操作等。

## 1. Java的8中数据类型

byte    short	long float	double	boolean	char



## 2.装箱和拆箱

1. 装箱：自动装箱是Java编译器将基本数据类型转化成对应的包装类型。例如：int转化为integer，double转化为Double。
2. 拆箱：与自动装箱相反，自动拆箱是Java编译器自动将包装类型转化为对应的基本数据类型。

原始类型：boolean，char，byte，short，int，long，float，double

封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

## 3. int和Integer的区别

1. Integer是int的包装类，int是Java的基本数据类型。
2. Integer变量必须实例化后才能使用，而int不需要。
3. Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向对象；而int则是直接存储数据值。
4. Integer默认值是null，int的默认值是0；

![image-20230304155256440](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230304155256440.png)

## 4.Java基本数据类型和引用数据类型

1. 基本数据类型：byte，int，long，short，float，double，boolean，char。
2. 引用数据类型：类（class），接口（interface），数组（[]）

![Java数据类型结构图](http://c.biancheng.net/uploads/allimg/190909/5-1ZZZ91512493.jpg)

## 5.Java的特点

1. 面向对象
2. 平台无关性
3. 简单性
4. 解释执行
5. 支持多线程
6. 分布式
7. 健壮性
8. 高性能
9. 安全性

## 6.private用法

private表示私有的，是一种访问控制修饰符，用于修饰类、属性和方法。只能自己使用，不能被别的类或者方法访问。也就是说对别的类是隐藏不可见的，private一般不修饰类，但可以修饰内部类。private不能用于外部类的封装，但是可以用于内部类的封装。

### Java中private关键字的使用方法

1. 只能在同一类中访问
2. 不能分配给外部类和接口
3. 创建完全封装的类，private关键字的最佳用法是通过使该类的所有数据成员变为私有来在Java中创建一个完全封装的类。



## 7.Java支持的四种访问权限

Java中访问修饰符包括了四种：private、default、protected和public，四种访问修饰符对元素的访问限制，由强到弱一次是private、default、protected和public。

1. private：如果一个元素声明为private，那么只有同一个类下的元素才可以访问它；
2. default：如果一个元素声明为default，那么只有同一个包下的元素才可以访问它；
3. protected：如果一个元素声明为protected，那么只有同一个包下的元素或者子类中的元素才可以访问它；
4. public：如果一个元素声明为public，那么所有位置的元素都可以访问它。

## 8.文件读取

1. FileReader类是将文件按字节流的方式读取char数组或者String
2. FileInputStream则按字节流的方式读取文件byte数组。

## 9.应届生在找Java开发岗时，常被问到的问题：



### 1.介绍一下Java的特点和优势是什么？

**特点**：

- 简单性：Java是一种面向对象的语言，底层借鉴c++但又不完全相同，Java并不支持多继承、指针、go to语句、操作符重载、头文件等，其语法基于c语言，免去了预处理操作。
- 面向对象：面向对象进行编程，基本思想是使用对象、类、封装、继承、多态等概念进行程序设计。每个物体都可以成为一个对象，其本身是唯一，有各自状态，对Java来说，先有类，才有对象，对象是类实例化后的产物。
- 可移植性：Java可以跨平台移植，Java环境安装好之后，会自带一个Java的虚拟机，他可以屏蔽掉不同操作系统之间的差异，实现跨平台运行Java程序。
- 高性能：在实际编写项目的过程中，用到一些Java中间件，例如：网管、缓存、负载均衡、数据库、分布式架构等，这些可以提高项目性能，同时Java可以通过虚拟机来优化提升运行效率。
- 分布式：分布式系统是由多个节点组成在一起的系统，主要有增加系统容量、加强系统可用、扩展性高、通过服务模块拆分提升响应效率、团队协作流程得到改善等优点。
- 动态性：Java中的动态特性主要体现在反射机制、动态字节码、动态编译、执行其他脚本编码等方面，可以实现各模块之间的互连。
- 多线程：一个进程可以启动多个线程。
- 安全性：Java安全措施主要体现在面向对象的规范上，包括：封装数据细节，只提供给接口给用户、在Java除了基本类型的操作外都是引用的操作、数组边界检查、强制类型转换和语言对线程的支持。
- 健壮性：在Java中有一种机制：自动垃圾回收机制（GC机制），Java虚拟机负责调动该机制，不需要编码者过多的干涉。

**优势**：

- 简单易学
- 跨平台
- 安全：没有指针，没办法直接访问内存，也不容易出现内存泄漏
- 多线程
- 丰富的类库
- 使用广泛

### 2.什么是面向对象编程？Java是面向对象语言吗？

- 以对象为导向进行编程，万物皆对象。Java是面向对象的编程的语言。

### 3.Java中的抽象类和接口有什么区别？

- 语法层面的区别

1. 抽象类可以提供成员方法的实现细节，而接口只能存在public abstract（隐式 声明）方法；
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final（隐式声明）类型的（必须在声明时赋值）；
3. 接口中不能含有静态代码块以及静态方法，而抽象类可以 有静态代码块和静态方法；
4. 一个类只能继承一个抽象类，而一个类可以实现多个接口。

![img](https://img-blog.csdnimg.cn/00b5f4572d904aeaacbfdb9bfeaa93eb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOh6YC45p2w54ix5a2m5Lmg,size_20,color_FFFFFF,t_70,g_se,x_16)

- 设计层面上的区别

1. 抽象类是对一种事务的抽象，是对整个类进行抽象，包括属性，行为（方法）。接口是 对行为（方法）的抽象。如果一个类继承或者实现了某个抽象类，那么一定是抽象类。
2. 抽象类可以作为很多子类的父类，是一种模板设计，而接口是一种规范，它是一种辐射式设计，对于抽象类，如果需要添加新的方法，可以直接在抽象方法中添加实现，子类不变。对于接口，如果接口进行了变更，那么实现它的类都需要做变更。

具体参考链接：https://blog.csdn.net/weixin_66813230/article/details/123510909



### 4.Java中的多线程是怎样实现的？如何避免线程安全问题？

**Java多线程实现的方式有四种** 

1. 继承Thread类重写run方法创建线程

```java
public class MyThread extends Thread{
    @override
    public void run() {
        System.out.println("Thread");
    }
}
```

2. 实现Runnable接口创建线程，如果自己的类已经继承一个类，就无法再继承Thread，此时，可以实现一个Runnable接口

```java
public class RunnableThread implements Runnable{
    @override
    public void run() {
        System.out.println("runnable");
    }
}
```

3. 实现Callble接口通过FutureTask包装器来创建Thread线程

```java
public class callbleThread implements callable {
    @override
    public Object call() throws Exception {
        return "Callable";
    }
}
```

4. 使用ExecutorService、Callable、Future实现有返回结果的线程

**如何避免线程安全** 

- 线程安全：多个线程访问一个对象时，不考虑环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作，调用这个行为都可以获得正确的结果，那这个对象就是线程安全的。
- 线程不安全：多个线程访问一个对象，发生冲突时

**解决线程安全** 

- 悲观锁：认为自己在使用数据时，一定有别的线程来修改数据，所以在使用数据时先加锁确保数据不会被其他线程修改。
- 乐观锁：与悲观锁刚好相反，认为在使用数据时一定不会有别的线程来修改数据，就不会加锁，只是在更新数据的时候去判断之前有没有别的线程来更新数据。

1. 方法一：使用synchronized关键字，表现为原生语法层面的互斥锁，它是一种悲观锁，需要监听一个唯一的对象，通常是当前类的字节码对象。
2. 使用Lock接口下的实现类。
3. 使用线程本地存储ThreadLocal。当多线程作用同一个变量且互不干扰的场景下，可以使用ThreadLocal来解决。
4. 使用乐观锁

### 5.Java中的异常处理机制是什么？

1. 使用try...catch...finally语句处理

使用try...catch...finally去处理异常相当于提前把可能出现的问题都考虑好，并提供相应的解决方案，以保证程序的正常运行。如果出现了异常但是又没有提供相应的解决方案，那么程序将无法正常运行。

1. 在函数签名中使用throws声明交给函数调用者caller去解决。

该方法与上一种方法完全不同，此方法自己不对异常做任何处理，而是将异常抛给调用者，由调用者去对异常做具体的异常处理操作。

### 6.Java中的集合框架有哪些？它们之间的区别是什么？

Java集合主要分为两类：一类是集合（collection），用于存储一个元素集合；一类是图（Map），用于存储键值对映射。

collection：Set、List、Queue；

Set：HashSet、TreeSet；

Map：HashMap、TreeMap；

List：ArrayList、LinkedList；

HashSet：LinkedHashSet；HashMap：LinkedHashMap；

![img](https://img-blog.csdnimg.cn/img_convert/7a5fbf846582aeba9e2b04cd9f0f2b33.png)

#### Set

`Set`集合不能包含重复的元素，存储是无序的。

**特点** 

1. set提供了`HashCode`和`equals`方法，所以set支持比较
2. set允许存储一个null值，并且不为空
3. 主要实现有：`HashSet`、`TreeSet`、`LinkedHashSet`
4. 不等于随机性，根据`Hash值`来排序

HashSet：线程不安全，可以存放null值。底层用hashmap来保存元素。

Hash添加add：

1. 调用`hashcode`算法计算元素哈希值，hash通过计算出在`hashset`底层数组中的存放位置（索引位置）
2. `哈希值`存在数据就用链表的形式来存储
3. `hash`值不同就添加成功，如果`hash`相同，进而需要调用`equals`方法来判断元素是否存在
4. `七上八下`



#### List

1. List集合的特点：

- 元素允许重复
- 各元素的顺序就是插入的顺序
- 可以存放null值

2. List的实现类有：

- `ArrayList`：数组实现，查询快，增删慢，轻量级（线程不安全）
- `LinkedList`：双向链表实现，增删快，查询慢（线程不安全）
- `Vector`：数组实现，重量级（线程安全、使用少）



#### Map

**特点** ：key可以为null值（只能一个null），value也可以为null

底层实现方式：

1. 以hash表实现的，内部定义一个hash数组，通过计算找索引去存储。
2. 底部是数组+链表/红黑树
3. 转化为红黑树前会判断链表`大于8`但是数组长度`小于64`，会进行数组扩容不会转为红黑树。

**TreeMap特点**：

1. 天然支持排序，默认自然排序
2. `synchronized`来实现锁，实现线程安全，效率低

**HashTable**：线程安全，`synchronized`来实现锁，实现线程安全，效率低。



### 7.Java中的JVM是什么？它是如何工作的？

- jvm是Java虚拟机的缩写，

### 8.什么是Spring框架？它的作用是什么？

### 9.什么是Hibernate框架？它的作用是什么？

### 10.如何使用Java实现网络编程？

### 11.Java中的IO流是什么？如何使用？

### 12.如何进行Java代码的性能优化？

### 13.什么是设计模式？你最常使用哪些设计模式？

**设计模式**是对**面向对象**设计中反复出现的问题的**解决方案**。

分为三大类：

1. 创建型模式
2. 结构型模式
3. 行为模式

设计模式参考链接：https://blog.csdn.net/weixin_57504000/article/details/124195306

### 14.你了解什么是单元测试吗？你常用的Java单元测试框架是什么？

**单元测试**：对软件中最小可测单元的检查和验证。



### 15.你是否了解过Java虚拟机的垃圾回收机制？



## 10.static和final的区别

static：是静态的意思

final：是最后的意思

区别：

1. final可以修饰类、方法和变量；static只能修饰方法和变量
2. final可以修饰全局变量和局部变量；static只能修饰全局变量，不能修饰局部变量
3. final不可以修饰代码块；static可以修饰代码块



## 11.cookie和session的区别

1. cookie可以存储在浏览器或者本地；session只能存在服务器
2. cookie只能存储String类型的对象；session能够存储任意的Java对象，
3. cookie安全性比session更弱（cookie有安全隐患，通过拦截本地文件找得到cookie后进行攻击）
4. session占用服务器性能，session过多，增加服务器压力
5. 单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie，session是没有大小限制和服务器内存大小有关。



## 12.访问控制修饰符

**public e private t default protected** 

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20230307103320539.png" alt="image-20230307103320539" style="zoom:150%;" />



## 13.equals和 “==”的区别

1. 对于字符串变量来说，使用“==”和“equals()”两种方法比较字符串时，其比较方法不同。

“==”比较两个变量本身的值，即两个对象在内存中的首地址

“equals()”比较字符串中所包含的内容相同。

2. 对于字符串变量来说，“==”和“equals”两种方法作用相同，都是用来比较其对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。

== ==的作用是判断两个对象的地址是否相等==。

==equals()：它的作用是判断两个对象是否相等。她一般有两种情况：==

**情况1：类没有覆盖equals()方法，等价与==比较两个对象**

**情况2：类覆盖了equals()方法，它用来比较的是两个对象的内容是否相等。**





## 14.异常



## 15、Redis数据库为什么快

1. ==Redis是内存数据库==，Redis是一个基于内存的数据库，它的数据存储在内存中，这样读写速度快，传统的数据库是磁盘数据库，

2. ==数据结构简单==，对数据的操作也相对简单。Redis中的数据结构是专门进行设计的，每一种数据结构都有一种或多种数据结构进行支持。Redis正是依赖这些灵活的数据结构，来提升数据的读取性能。
3. ==采用单线程==，省去很多上下文切换以及CPU的消耗，不存在竞争条件，不用考虑各种锁的问题，也不会出现死锁而导致消耗性能的情况。
4. 使用==基于IO的多路复用机制的线程模型==，可以处理并发的链接。



## 16、Java语言的特点

1. 简单易学
2. 面向对象
3. 平台无关性
4. 安全性
5. 可靠性
6. 支持多线程
7. 支持网络编程
8. 编译与解释共存



## 17、什么是JDK

**JDK是Java Development Kit，它是==功能齐全的Java SDK==。它==拥有JRE所有的一切==，还有==编译器（javac）==和==工具（如javadoc和jdb）==。它能够创建和编译程序**。



## 18、什么是JRE

**JRE是Java运行环境（Java Runtime Environment，简称JRE）**是一个软件,**JRE是Java运行时环境**。它是运行运行已编译Java程序所需的所有内容的集合，包括J**ava虚拟机（jvm）**，**Java类库**，**Java命令**和**其他的一些基础结构**。但是，它不能用于创建新程序。



## 19、什么是JVM

**JVM 是 Java Virtual Machine（Java 虚拟机）**的缩写，**它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的**。[Java](https://baike.baidu.com/item/Java/85979?fromModule=lemma_inlink)虚拟机有自己完善的[硬体](https://baike.baidu.com/item/硬体/1298863?fromModule=lemma_inlink)架构，如处理器、[堆栈](https://baike.baidu.com/item/堆栈/1682032?fromModule=lemma_inlink)、[寄存器](https://baike.baidu.com/item/寄存器/187682?fromModule=lemma_inlink)等，还具有相应的指令系统。**Java虚拟机屏蔽了与具体操作系统平台相关的信息**，使得Java程序只需生成在Java虚拟机上运行的[目标代码](https://baike.baidu.com/item/目标代码/9407934?fromModule=lemma_inlink)（[字节码](https://baike.baidu.com/item/字节码/9953683?fromModule=lemma_inlink)），就可以在多种平台上不加修改地运行。



## 20、什么是SDK

**SDK 就是 Software Development Kit 的缩写，中文意思就是==软件开发工具包==,**软件开发工具包一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。



## 21、Java与c++的区别

- 都是面向对象的语言，都支持封装、继承和多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类单继承，c++的类是多继承，但是Java接口可以多继承
- Java有自动内存管理机制，需要程序员手动释放无用内存



## 22、Java和c的区别

1、单文件的编译时间java比C语言快；

2、==C语言可以直接操作内存，java不能直接操作==；

3、==C语言可以封装动态库，java不行==；

4、==C语言有指针，java没有指针==；

5、==C语言可以直接操作串口，java需要第三方jar包支持==等等。

6、==C语言的代码不容易跨平台，java的代码容易跨平台==；

7、==C语言的线程更加灵活，java的线程都已经封装好了==；

8、==C语言做单独功能，可以增加效率==，==java适用做web应用开发==；

9、==JAVA的开源包太多了，C语言也有但是偏少==，而且面向某个业务应用领域的框架没java多。



## 23、重载

重载就是同样一个方法能够根据输入数据的不同，做出不同的处理。

特点：

1. 同一个类中
2. 方法名必须相同
3. 参数类型不同
4. 个数不同
5. 顺序不同
6. 方法返回值和访问修饰符可以不同



## 24、重写

重写就是子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，需要对父类方法重新编写。

特点：

1. 返回值类型、方法名、参数列表必须相同，抛出的异常小于等于父类，访问修饰符大于等于父类。
2. 如果父类方法的访问修饰符为private/final/static则子类就不能对父类方法进行重写，但被static修饰的方法能够被再次声明
3. 构造方法无法被重写

重写遵循的规则：两同量小一大

- 两同：方法名相同，形参列表相同
- 两小：子类返回值类型应比父类返回值类型更小或者相等；子类方法声明抛出的异常应比父类方法声明抛出的异常小或者相等。
- 一大：子类方法的访问权限应比父类方法的访问权限更大或者相等



## 25、面向对象编程的三大特性：封装、继承、多态

### 1、封装

封装就是把一个对象的属性私有化，同时提供一些可以被外界访问的属性方法。

### 2、继承

继承是将已经存在的类作为基础，新类的定义可以增加新的数据或者功能，也可以用父类的功能，但不能选择性的继承父类的功能。

继承特点：

1. 子类拥有父类对象所有的属性和方法，但是父类中的私有属性和方法子类无法访问，只能拥有。
2. 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
3. 子类可以用自己的方法实现父类的方法

### 3、多态

多态是指程序中定义的引用变量指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底指向那个类的实例，该引用变量发出的方法调用到底是哪个类中的实现方法，必须由程序运行期间才能决定。

多态（英语：polymorphism）指为不同数据类型的实体提供统一的接口。



## 26、String、StringBuffer和StringBuilder的区别是什么？String为什么不可变？

- ==可变性==

String类中使用final关键字修饰字符串数组用来保存字符串，所以不可变，StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串char[] value，但是没有final关键字修饰，因此这两种对象是可变的。

- ==线程安全性==

String不可变，可理解为常量，因此线程安全；StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，因此，线程安全；StringBuilder并没有对方法施加同步锁，因此非线程安全。

- ==性能==

每次对String修改，都会生成一个新的String对象，然后指针指向新的String对象；StringBuffer每次是对对象本身进行操作；StringBuilder会对StringBuffer获得10%~15%的性能提升。



## 27、接口和抽象类的区别

1. 所有接口中不能有方法实现；抽象类中可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量；抽象类中不一定
3. 一个类可以实现多个接口；但一个类只能实现一个类
4. 接口方法默认为public，抽象类可以有：public、protect、和default
5. 从设计层面来讲，抽象是对类的抽象，是一种设计模板；接口是对行为的抽象，是一种行为的规范。



## 28、==JDK8的新特性==

1. ==Lambda表达式==
       JDK8以前，我们编写匿名内部类，看着很繁琐。

       JDK8带来了Lambda表达式，编写代码更加简单，可以减少冗余代码。
        
       参考：Lambda表达式
        
                 Lambda表达式原理分析
        
                 Lambda表达式----常用的内置函数式接口
        
                 Lambda表达式----方法引用（JDK8 :: 双冒号的使用）

2.==集合之Stream流式操作==
       JDK8以前，我们对集合的操作很繁琐。

       JDK8带来了Stream流式操作新特性，使得开发人员对集合的操作变得更加简单，看起来更加优雅。
    
       参考：集合之 Stream 流式操作
    
                  Stream流 collect() 方法的详细使用介绍
    
                  并行 Stream 流的使用
    
                  Fork/Join 框架
    
                  多线程异步调用：CompletableFuture

3.==接口的增强==
       JDK8以前，接口里只有抽象方法，这样是不利于接口的扩展。

       JDK8对接口进行了增强，在接口中新增了默认方法和静态方法。
    
       参考：JDK8接口增强

4.==Optional中避免NullPointerException检查==
      JDK8以前，编写代码，通常会出现 NullPointerException (空指针异常)，通常情况下我们都是通过 if ... else...来对对象进行是否为空判断，然后再进行逻辑处理，代码写起来也比较冗余。

      JDK8新增了Optional类，使用该类可以避免我们对空指针的检查，使代码看起来比较优雅。
    
       参考：Optional 类的使用

5.==新的时间和日期API==
      JDK8以前，我们使用的时间和日期的API，在设计上是存在一些缺陷的，比如有两个 Date 类，一个在 java.util 包中，一个在 java.sql 包中。JDK8以前的时间API，是不支持并行操作的，不支持多线程。

      JDK8重新设计了一套API，这套 API 在设计上比较合理，并且也支持多线程操作。
    
      参考：JDK8时间和日期API

6.==可重复注解==
     JDK8以前，是不能在同一个位置放两个同样的注解，会报错。

     JDK8中，它带来了可重复注解新特性，它可以让我们在同一个位置放置两个一样的注解了。


## 29、==Lambda表达式==

Lambda 表达式是 JDK8 的一个新特性，可以取代大部分的匿名内部类，写出更优雅的 Java 代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。



## 30、Java和Python的区别

1. Java必须显式声明变量名，而动态类型的Python不需要声明变量。

2. Python虚拟机没有Java强，Java虚拟机是Java的核心，Python的核心是可以很方便地使用c语言函数或c++库。

3. Java是一种静态类型语言，Python是一种动态类型语言

4. Java 的类型要声明，Python 的类型不需要。

5. Python是全动态性的，可以在运行时自己修改自己的代码，Java只能通过变通方法实现。



## 31、为什么要使用多线程

- 从计算机底层来说：线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，这大大减少了线程上下文切换的开销。
- 从当代互联网发展趋势来说：线程数据量巨大，而多线程并发编程正是高并发系统的基础，利用好多线程的机制可以大大提高系统整体的并发力以及性能。



## 32、什么是上下文切换？

多线程编程中，一般线程个数都大于CPU核心的个数，而CPU核心在任意时刻只能被一个线程使用，为了让这些线程都得到有效执行，因此，CPU才去的策略是为每个线程分配时间片并轮转的形式。**当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就是上下文切换。**

## 33、==什么是线程死锁？==

**死锁：多个线程同时被阻塞，他们中的一个或多个线程全部都在等待某个资源被释放。==由于线程被无限期的阻塞，因此程序不可能正常终止==。** 

## 34、如何避免死锁？

1. ==破坏互斥条件==：这个没办法破坏，用锁本来就是要让他们互斥
2. ==破坏请求与保持条件==：一次性申请的所有资源
3. ==破坏不剥夺条件==：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
4. ==破坏循环等待条件==：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。

## 35、为什么要弄一个CPU高速缓存呢？

类比我们开发网站后台系统使用的缓存（比如Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题 。**CPU缓存则是为了解决==CPU处理速度==和==内存处理速度不对等==的问题**。

## 36、ThreadLocal内存泄漏问题了解不？

ThreadLocalMap中使用的key为ThreadLocal的弱引用，而value则为强引用。而ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key会被清理掉，而value不会被清理掉。ThreadLocalMap中就会出现key为null的Entry。假如我们不做任何措施的话，value永远不会被收回，这个时候就会造成内存泄漏。

## 37、为什么要用线程池？

**池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率**。

使用线程池的好处：

- ==降低资源消耗==。通过重复利用已创建的线程降低线程创建和销毁的造成的消耗
- ==提高相应速度==。当任务到达时，不用等待线程的创建就能立即执行。
- ==提高线程的可管理性==。线程是稀缺资源，如果进行无限的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。

## 38、强引用、软引用、弱引用

- **强引用**：我们实际上使用的大部分都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器不会回收它。当内存空间不足时，**Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会随意回收具有强引用的对象来解决内存不足的问题**。
- **软引用**：类似于可有可无的生活用品。如果空间足够，垃圾回收器就不会回收它，**如果内存空间不足了，就会回收这些对象的内存**。软引用可以用来实现内存敏感的高速缓存。
- **弱引用**：类似于可有可无的生活用品。弱引用于软引用的区别：只具有弱引用的对象拥有更短的生命周期。**一旦发现只具有弱引用的对象，不管内存空间足够否，都会回收它的内存**。

## 39、==Java反射机制==

**Java的反射（reflection）机制是指在程序的运行状态中，==可以构造任意一个类的对象==，==可以了解任意一个对象所属的类==，==可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法==。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键**。

## 40、HashMap和Hashtable的区别

==相同点==：

1. **HashMap和Hashtable都是java.util包下的类**

2. **HashMap和Hashtable都实现了Map接口，存储方式都是key-value形式**

3. **HashMap和Hashtable同时也都实现了Serializable和Cloneable接口**

4. **HashMap和Hashtable的负载因子都是0.75**

5. **HashMap与Hashtable的部分方法相同，如put，remove等方法**

==不同点==：

1. **HashMap是非线程安全的**，**Hashtable是线程安全的**

2. **HashMap允许null作为键或值**，**Hashtable不允许,运行时会报NullPointerException**

3. **HashMap添加元素使用的是自定义hash算法**，**Hashtable使用的是key的hashCode**

4. **HsahMap在数组+链表的结构中引入了红黑树，Hashtable没有**

5. **HashMap初始容量为16，Hashtable初始容量为11**

6. **HsahMap扩容是当前容量翻倍，Hashtable是当前容量翻倍+1**

7. **HsahMap只支持Iterator遍历，Hashtable支持Iterator和Enumeration**

8. **HsahMap与Hashtable的部分方法不同，比如Hashtable有contains方法**



## 41.创建线程的方式

1. 继承Thread类创建线程
2. 实现Runable接口创建线程
3. 使用Callable和Future创建线程
4. 使用线程池，例如Executor框架











# 二、MySQL

## 1、MySQL的连接查询

1. **内连接——inner join** 

- MySQL内连接就是两张表或者多张表同时满足某种条件的数据记录的集合
- 通常在from字句中使用关键字inner join来连接两张或者多张表，并使用on字句设置连接条件
- 内连接是系统默认的连接方式，所以from可以省略，只用join，同时有多个表 时，可以连续使用inner join来实现多表的内连接，不过为了性能更好，一般不要超过三个表。

```sql
selct from 表1 inner join 表2 on 表1.字段 = 表2.字段
```



2. **左连接——left join** 

- 左连接也可以成为左外连接。在from字句中使用left join 或者left out join关键字来表示。
- 左连接以左侧表为基础表，接收左侧表的所有行，并用这些行与右侧表中的记录进行匹配，也就是说匹配左侧表的所有行以及右表中符合条件的行。
- 左连接中，左表的记录会全部表示出来，右表只会表示符合搜索条件的记录，不足的地方均为null。

```sql
selct 字段 from 表1 left join 表2 on 表1.字段 = 表2.字段
```



3. **右连接——right join** 

- 右连接又被成为右外连接。在from字句中使用right join或者right out join关键字表示。
- 右连接跟左连接恰好相反，它是以右表为基础，接收右表中的所有行，并用这些记录与左表中的行进行匹配。

```sql
select 字段 from 表1 right join 表2 on 表1.字段 = 表2.字段
```

4. **自连接（自查询）** 

```sql
select 字段 from 表1, 表2 where 表1.id = 表2.id
```

5. **自查询（嵌套查询）** 

```sql
select * from student where class_id=(select class_id from student where username = "张三")
//查询张三的同班同学
```



## 2、MySQL的表优化问题

1. **选择最合适的字段属性**

MySQL是一种关系型数据库，可以很好的支持大量数据的存储。但是一般来说，数据库中的表越小，查询越快，因此在创建表的时候，为了获得更好的性能，可以将表中字段的宽度尽可能设的小一点。

2. **尽量把字段设置为NOT NULL** 

尽量把字段设置为NOT NULL，这样将来在执行查询语句的时候，数据库不用去比较NULL值。

3. **使用连接（join）代替自查询（Sub-Queries）** 

MySQL从4.1开始支持SQL的自查询。这个技术可以使用select语句来创建一个单例查询结果，然后把这个结果作为过滤条件用在另一个查询语句中。

连接（join）之所以更有效率一些，是因为MySQL不需要创建临时表来完成这个逻辑。

4. **使用联合（Union）来代替手动创建的临时表** 

MySQL从4.0版本开始支持联合（Union）查询，他可以把需要使用临时表两条或者多条select查询合在一个查询中。在客户端查询会话结束时，临时表会被自动删除，从而保证数据整齐、高效。使用union来创建查询的时候，我们只需要使用union作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要相同。

注意：当能够确认查询结果不可能重复的时候，或者不在乎重复结果的时候，尽量使用union all而不是union。因为union和union all的主要区别是union需要将两个或多个结果集合并后再进行唯一性过滤操作，这就涉及到排序，增加大量的CPU运算，增大资源消耗及延迟。

5. **事务** 

尽管我们可以使用子查询(Sub-Queries)、连接(JOIN)和联合(UNION)来创建各种各样的查询，但不是所有的数据库操作，都可以只用一条或少数几条就可以完成的。更多的时候是需要用一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。

设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是要么语句块中每条语句都操作成功，要么都失败。

**就是可以保证数据库中数据一致性和完整性。事务以BEGIN关键字开始，以COMMIT关键字结束。在这之间的一句SQL语句操作失败，那么Rollback命令可以数据库恢复到begin开始之前的状态。** 

事务的另外一个作用是当多个用户同时使用相同的数据源时，他可以使用锁定的方式为用户提供一个安全的访问机制，这样可以保证用户的操作不被其他用户所干扰。

**事务必须满足四个条件（ACID）：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）**。

- ==原子性==：一个事务(transaction)中的所有操作，**要么全部完成，要么全部不完成**，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚(Rollback)到事务开始的状态，就像这个事务从来没有执行过一样。

- ==一致性==：**在事务开始之前和事务结束之后，数据库的完整性没有被破坏**。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

- ==隔离性==：**数据库允许多个事务同时对其数据进行读写和修改的能力**，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同的级别，包括读未提交(Read uncommitted)、读已提交(Read committed)、可重复读(repeateable read)和串行化(Serializable).

- ==持久性==：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失**。


6. **使用外键** 

使用表锁定的方法可以维护数据的完整性，但是却不能保证数据的关联性。这个时候我们可以使用外键。

7. **锁定表 ** 

尽管事务是维护数据库完整性的一个非常好的方法，但却因为他的独占性，有时会影响数据库的性能，尤其是很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其他的用户请求只能暂时等待直到该事务结束。

如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。

其实，有些情况下我们可以通过锁定表的方式来获得更好的性能。下面的例子就是锁定表的方法来完成前面一个例子中事务的功能。

这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其他访问来对inventory进行插入、更新或者删除的操作。


8. **使用索引** 

索引是提高数据库性能的常用方法，他可以令数据库服务器比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。

那该对那些字段进行索引呢？

一般来说，索引应该建立在那些将用于join，where判断和orderby排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引，对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况。

例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。

此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。


9. **优化de的查询语句** 

- ==不使用子查询== 

例：SELECT * FROM t1 WHERE id (SELECT id FROM t2 WHERE name=’hechunyang’);

子查询在MySQL5.5版本里，内部执行计划器是这样执行的：先查外表再匹配内表，而不是先查内表t2，当外表的数据很大时，查询速度会非常慢。

在MariaDB10/MySQL5.6版本里，采用join关联方式对其进行了优化，这条SQL会自动转换为

```sql
 SELECT t1.* FROM t1 JOIN t2 ON t1.id = t2.id;
```




但请注意的是：优化只针对SELECT有效，对UPDATE/DELETE子查询无效，固生产环境应避免使用子查询

- ==避免函数索引== 

例：

```sql
SELECT * FROM t WHERE YEAR(d) >= 2016;
```




由于MySQL不像Oracle那样支持函数索引，即使d字段有索引，也会直接全表扫描。

应改为

```sql
SELECT * FROM t WHERE d >= '2016-01-01';
```

- ==用IN来替换OR== 

低效查询

```sql
SELECT * FROM t WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30;
```

高效查询

```sql
SELECT * FROM t WHERE LOC_IN IN (10,20,30);
```

- LIKE双百分号无法使用到索引

```sql
SELECT * FROM t WHERE name LIKE ‘%de%’;
```

```sql
SELECT * FROM t WHERE name LIKE ‘de%’;
```


目前只有MySQL5.7支持全文索引（支持中文）

- ==读取适当的记录LIMIT M,N== 

```sql
SELECT * FROM t WHERE 1;
SELECT * FROM t WHERE 1 LIMIT 10;
```

- ==避免数据类型不一致== 

```sql
SELECT * FROM t WHERE id = ’19’;
SELECT * FROM t WHERE id = 19;
```

- ==分组统计可以禁止排序== 

```sql
SELECT goods_id,count(*) FROM t GROUP BY goods_id;
```


默认情况下，MySQL对所有GROUP BY col1，col2…的字段进行排序。如果查询包括GROUP BY，想要避免排序结果的消耗，则可以指定ORDER BY NULL禁止排序。

```sql
SELECT goods_id,count(*) FROM t GROUP BY goods_id ORDER BY NULL;
```

- ==避免随机取记录== 

```sql
SELECT * FROM t1 WHERE 1=1 ORDER BY RAND() LIMIT 4;
```


MySQL不支持函数索引，会导致全表扫描 

```sql
SELECT * FROM t1 WHERE id >= CEIL(RAND()*1000) LIMIT 4;
```

- ==禁止不必要的ORDER BY排序== 

```sql
SELECT count(1) FROM user u LEFT JOIN user_info i ON u.id = i.user_id WHERE 1 = 1 ORDER BY u.create_time DESC;
SELECT count(1) FROM user u LEFT JOIN user_info i ON u.id = i.user_id;
```

- ==批量INSERT插入== 

```sql
INSERT INTO t (id, name) VALUES(1,’Bea’);
INSERT INTO t (id, name) VALUES(2,’Belle’);
INSERT INTO t (id, name) VALUES(3,’Bernice’);

INSERT INTO t (id, name) VALUES(1,’Bea’), (2,’Belle’),(3,’Bernice’);
```



## 3、MySQL的分页查询

### 1.limit用法，

可以使用一个参数或者两个参数进行查询。第一个参数：偏移量；第二个参数：数据条数。

- 单参数，即默认偏移量为0，从第一行开始取，一共取rows条。

```mysql
/*查询前10条*/
SELECT * FROM student LIMIT 10;
```

- 双参数

```mysql
/*查询前10条*/
SELECT * FROM student LIMIT 0,10;
/*查询第10-20条*/
SELECT * FROM student LIMIT 10 OFFSET 20;
```

### 2.分页公式

- 总页数计算，在计算总页数过程中，需要用到COUNT函数和向上取整函数CEIL，核心信息如下：

```mysql
/*获取数据总条数*/
SELECT COUNT(*) FROM Student;
/*假设每页显示10条，则直接进行除法运算，然后向上取整*/
SELECT CEIL(COUNT(*) / 10) AS pageTotal FROM Student;
```

- 核心信息：
  - 当前页：pageNumber
  - 每页数据量：pageSize

在实际操作中，我们能够得到的信息有当前所在页以及每页的数据量，同时要注意一下是否超出了最大页数。以每页10条为例，则前三页的数据应为：

- 第1页：第1~10条，SQL写法：LIMIT 0,10
- 第2页：第11~20条，SQL写法：LIMIT 10,10
- 第3页：第21~30条，SQL写法：LIMIT 20,10

据此我们可以总结出，LIMIT所需要的两个参数计算公式如下：

- `offset`：(pageNumber - 1) * pageSize
- `rows`：pageSize

## 4、6种SQL分页查询方法总结

#### 方法1: 直接使用数据库提供的SQL语句

```mysql
SELECT * FROM 表名称 LIMIT M,N;
```

#### 方法2：建立主键或唯一索引, 利用索引(假设每页10条)

```mysql
SELECT * FROM 表名称 WHERE id_pk > (pageNum*10) LIMIT M
```

#### 方法3: 基于索引再排序

```mysql
 SELECT * FROM 表名称 WHERE id_pk > (pageNum*10) ORDER BY id_pk ASC LIMIT M
```

#### 方法4: 基于索引使用prepare

```mysql
PREPARE stmt_name FROM SELECT * FROM 表名称 WHERE id_pk > (？* ？) ORDER BY id_pk ASC LIMIT M
```

#### 方法5:利用MySQL支持ORDER操作可以利用索引快速定位部分元组,避免全表扫描

```mysql
SELECT * FROM your_table WHERE pk>=1000 ORDER BY pk ASC LIMIT 0,20
```

#### 方法6: 利用"子查询/连接+索引"快速定位元组的位置,然后再读取元组. 道理同方法5

```mysql
SELECT* FROMyour_table WHEREid <= (SELECTid FROMyour_table ORDER
BYid descLIMIT (page − 1 ) ∗ page-1)*page−1)∗pagesize ORDERBYid desc LIMIT $pagesize
```

利用连接示例:

代码如下:

```mysql
SELECT* FROMyour_table ASt1
JOIN(SELECTid FROMyour_table ORDERBY
id descLIMIT (page − 1 ) ∗ page-1)*page−1)∗pagesize ASt2
WHERE t1.id <= t2.id ORDERBYt1.id descLIMIT $pagesize;
```



## 5、什么是MySQL

MySQL是一种关系型数据库，在Java企业级开发中常常用到。MySQL代码是开源的，默认端口为3306.

## 6、MyISAM和InnoDB的区别

1. 是否支持行级锁：MyISAM只支持表级锁，InnoDB支持行级锁和表级锁，默认为行级锁。
2. 是否支持事务和奔溃后的安全恢复：MyISAM强调的是性能，执行比InnoDB快，但不提供事务。InnoDB支持事务等。
3. 是否支持外键：MyISAM不支持；InnoDB支持。
4. 是否支持MVCC(multi-version-concurrent-control，多版本并发控制)：仅InnoDB支持。



## 7、索引

MySQL索引使用的数据结构主要有BTree索引和哈希索引。对于哈希索引来说，底层数据结构为哈希表，因此在查询单条记录的时候，可以选择哈希索引，查询性能最快。其余大部分场景，建议选择BTree索引。

## 8、什么是事务

**事务逻辑上的一组操作，要么都执行，要么都不执行。事务就是保证这两个关键操作要么都成功，要么都不成功**。



## 9、事务的四大特性（ACID）

- **原子性**（Atomicity）：事务最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。
- **一致性**（Consistency）：执行事务前后，数据保持一致，多个事务对同一数据的读取的结果是相同的。
- **隔离性**（Isolation）：并发访问数据库时，一个用户的食物不被其他事务所干扰，各并发事务之间数据库是相互独立的。
- **持久性**（Durability）：一个事务被提交后，它对数据库的改变是持久的，即使数据库发生故障也不应该对其有任何影响。



## 10、并发事务带来哪些问题？

- **脏读**（Dirty read）：一个事务读取并使用了另外一个事务修改但为提交的数据。
- **丢失修改**（Lost to modify）：一个事务访问数据后，另外一个事务也访问了该数据，使得第一个事务修改的结果
- **不可重复读**（Unrepeatable read）：一个事务访问数据时，另外一个事务在其还未结束时访问该数据，使得第一个事务前后读取的数据结果不一致。
- **幻读**（Phantom read）：一个事务读取几行数据后，另外一个事务向数据中插入了一些数据，使得第一个事务读取的数据多了一些原本不存在的数据，称为幻读。



## 11、事务的隔离级别有哪些？MySQL的默认隔离级别是？

- **READ-UNCOMMITED**(读取未提交)
- **READ-COMMITED**(读取已提交)
- **REPEATABLE-READ**(可重复读)
- **SERIALIZABLE**(可串行化)

**MySQL InnoDB存储引擎的默认支持的隔离级别是REPEATABLE-READ（可重读）**。

## 12、表级锁和行级锁

- **表级锁**：MySQL中锁定粒度最大的一种锁，对整张表加锁，实现简单，加锁快， 资源消耗较少，不会出现死锁，触发锁冲突的概率最高。
- **行级锁**：MySQL中锁定粒度最小的一种锁，只对当前操作行进行加锁，行级锁能大大减少数据库操作的冲突，加锁粒度最小，并发度高，加锁开销也最大，加锁慢，会出现死锁。



##  13、大表优化

- **限定数据的范围**：务必禁止不带任何限制数据范围条件的查询语句
- **读/写分离**：经典的数据库拆分方案，主库负责写，从库负责读
- **垂直分区**：根据数据库里面数据表的相关性进行拆分。简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。
- **水平分区**：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到分布式的目的。水平拆分可以支持非常大的数据量。



## 14.创建索引的注意事项

1. 尽量选择不要索引null的关键字
2. 选择区分度列作为索引
3. 用于group by和order by的字段
4. 被频繁查询字段，作为查询条件
5. 频繁更新的字段创建索引需谨慎









# 三、计算机基础

## 1、三种网络体系结构

- ==OSI的体系结构== 

**物理层、数据链路层、网络层、运输层、会话层、表示层、应用层**

- ==TCP/IP的体系结构== 

**网络层、网际层、运输层、应用层**（==各种应用层协议和TELNET,FIP,SMTP==等）

- ==五层协议的体系结构== 

**物理层、数据链路层、网络层、运输层、应用层**



**应用层**：

**应用层的任务是通过应用进程间的交互完成特定网络应用**。应用层协议定义的是应用程序间的通信和交互规则。对于不同网络应用需要不同的应用层协议。例如：域名系统DNS；支持万维网的HTTP协议；支持电子邮件的SMTP协议等等。我们把应用层交互的数据单元称为报文。

**运输层**：

**运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。运输层主要使用一下两种协议

1. **传输控制协议TCP**（Transmission Control Protocol）——提供面向连接的，可靠的数据传输服务。
2. **用户数据协议UDP**（User Datagram Protocol）——提供无连接的，尽最大努力的数据传输服务。

**网络层**：

**在计算机网络之中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换节点，确保数据即使传送**。

互联网是有大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是**无连接的网际协议（Inter Protocol）**和许多**路由选择协议**，因此互联网的网络层也叫做**网际层或者IP层**。

**数据链路层**：

**数据链路层（data link layer）通常称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议**。

**物理层**：

**物理层（physic layer）的作用是实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异**。



## 2、TCP三次握手

- 客户端——发送带有SYN标志的数据包，一次握手——服务端
- 服务端——发送带有SYN/ACK标志的数据包，二次握手——客户端
- 客户端——发送带有ACK标志的数据包，三次握手——服务端



## 3、四次挥手

- 客户端——发送一个FIN，用来关闭客户端到服务器的数据传送（我没啥说的了）
- 服务器——收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN占用一个序号（我知道了）
- 服务器——关闭与客户端的连接，发送一个FIN给客户端（我没啥要说的了）
- 客户端——发回ACK报文确认，并将确认序号设置为收到序号加1（我知道了）



## 4、TCP和UDP协议的区别

- TCP面向连接；UDP无连接
- TCP传输可靠；UDP传输不可靠
- TCP以字节流形式传输；UDP以报文段形式传输
- TCP传输速度慢；UDP传输速度快
- TCP应用于要求通信传输可靠场景；UDP应用于要求传输速度快的场景
- TCP首部20-60个字节；UDP首部8个字节



## 5、ARQ协议

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠的基础上实现可靠的信息传输。



## 6、状态码

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Information（信息性状态码）      | 接收的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error                     | 服务器处理请求出错         |



## 7、Cookie和Session的区别

1. **对象不同**

cookie：针对每个网站的，使得其他网站无法访问，这个文件保存在客户端。cookie：大致包括用户名，密码，设置等信息

session：是针对每个用户的，只有客户端才能访问，程序为该客户端添加一个session。session：主要包括登录信息和操作信息等

2. **存储数据大小不同**

cookie：一个cookie存储的数据大小不超过3k

session：session存储在服务器上，可以任意存储数据。当session存储数据太多时，服务器可选择进行清理。

3. **生命周期不同**

cookie：cookie的生命周期随着浏览器关闭就消亡了，时间是累计的，从创建开始计时，30分钟后生命周期结束。

session：session生命周期是间隔的，从创建开始计时，如果30分钟内没有访问，那么session生命周期就被销毁。

4. **存储位置不同**

cookie：cookie数据保存在客户端

session：session数据保存在服务器端

5. **数据类型不同** 

两者都是key-value结构，但是value类型是有差异的

cookie：value只能是字符串类型

session：value是object类型

6. **安全性不同** 

cookie：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗

session：session相对较为安全



## 8、HTTP和HTTPS的区别

- HTTP是超文本传输协议，信息是明文传输，HTTPS是具有安全性的SSL加密传输协议
- HTTP和HTTPS使用的是完全不同的连接方式，HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

- 用的端口不一样，HTTP的端口为80，HTTPS的端口为443



# 四、操作系统

## 1、什么操作系统

- **操作系统（Operating System，简称OS）是管理计算机硬件与软件资源的程序，是计算机操作的基石**。
- **操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机的硬件和软件资源**。
- **操作系统的存在屏蔽了硬件层的复杂性**
- **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。**内核是连接应用程序与硬件的桥梁，决定着系统的性能和稳定。



## 2、进程间的通信方式

1. **管道/匿名管道**（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信
2. **有名管道**（Names Pipes）：克服了匿名管道只能用于具有亲缘关系进程通信的缺点。有名管道严格遵循先进先出。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程间通信。
3. **信号**（Signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个时间已经发生。
4. 消息队列（Message Queuing）：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

5. **信号量**（Semaphores）：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

6. **共享内存**（Shared memory）：使得多个进程可以同时访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。
7. **套接字**（Sockets）：此方法主要用于在客户端和服务器之间通过网络进行通信。



## 3、线程间的同步通信方式

1. **互斥量**（Mutex）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以**保证公共资源不会被多个线程同时访问**。
2. **信号量**（Semphares）：**它允许同一时刻多个线程访问同一资源**，但是需要**控制**同一时刻访问此资源的**最大线程数量**。
3. **事件**（Event）：**通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作**。



## 4、常见的几种内存管理机制

1. **块式管理**：将内存几个固定大小的块，每个块中只包含一个进程。
2. **页式管理**：把内存分为大小相等且固定的一页一页的形式，页较小，划分力度更大，提高了内存利用率，减少了碎片。通过页面对应逻辑地址和物理地址。
3. **段式管理**：把内存分为一段一段的，比页更小。通过段表对应逻辑地址和物理地址。



# 五、Redis

## 1、什么是Redis

**Redis（Remote Dictionary Server )**，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的**日志型**、**Key-Value数据库**，并提供多种语言的API。



## 2、分布式缓存常见的技术选型方案有哪些？

- Memcached（现在基本没用）
- Redis（直接用）

## 3、Redis数据库为什么快

1. ==Redis是内存数据库==，Redis是一个基于内存的数据库，它的数据存储在内存中，这样读写速度快，传统的数据库是磁盘数据库，

2. ==数据结构简单==，对数据的操作也相对简单。Redis中的数据结构是专门进行设计的，每一种数据结构都有一种或多种数据结构进行支持。Redis正是依赖这些灵活的数据结构，来提升数据的读取性能。
3. ==采用单线程==，省去很多上下文切换以及CPU的消耗，不存在竞争条件，不用考虑各种锁的问题，也不会出现死锁而导致消耗性能的情况。
4. 使用==基于IO的多路复用机制的线程模型==，可以处理并发的链接。



## 4、定期数据删除的策略

- 惰性删除：只会在取出key的时候才对数据进行过期检查，这样对CPU最友好，但可能造成太多过期key未被删除。
- 定期删除：每隔一段时间抽取一批key执行删除过期key的操作，并且Redis会通过限制删除操作的执行的时长和频率来减少删除操作对CPU时间的影响。



## 5、Redis内存淘汰机制

1. volatile-lru（least recently used）：从设置过期时间的数据集中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集中任意挑选数据淘汰
4. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中移除最近最少使用的key
5. allkeys-random：从数据集中任意挑选数据淘汰
6. no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。



## 6、什么是缓存穿透

**缓存穿透就是大量请求的key根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层**。

## 7、解决缓存穿透的方法

- 缓存无效key
- 布隆过滤器

## 8、什么是缓存雪崩

- 第一：缓存在同一时间大面积失效，后面的请求直接落到数据库上，造成数据库大时间内承受大量请求。

- 第二：有一些被大量访问的数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到数据库上。



## 9、解决缓存雪崩的办法

- 针对服务器不可用时：

1. 采用Redis集群，避免单机出现问题整个缓存服务没办法使用
2. 限流，避免同时处理大量请求

- 针对热点缓存失效的情况：

1. 设置不同的失效时间，比如随机设置缓存失效的时间
2. 缓存永不失效

## 10、如何保证缓存和数据库数据的一致性？

- 缓存失效时间变短（不推荐，治标不治本）
- 增加cache更新重试机制（常用）：如果cache服务不可用导致缓存删除失败的话，就隔一段时间进行重试，如果重试多次还是失败的话，可以把当前更新失败的key存入队列中，等缓存服务可用之后，再将缓存中对应的key删除即可。

## 11、Redis事务

**Redis可以通过MULTI，EXEC，DISCARD和WATCH等命令来实现事务（transaction）功能**。

**Redis是不支持roll back的，因而不满足原子性（而且不满足持久性）**。

**Redis提供了一种将多个命令请求打包的功能。然后再按顺序执行打包的所有命令，并且不会被中途打断**。

















# 六、通信协议工程师

## 1、4G分为哪几种制式，分别被哪几家运营商使用

1、**中国移动 ** 

移动4G：移动TD-LTE；

移动3G：TD-SCDMA；

移动2G：GSM。

2、**中国联通 **

联通4G：联通TD-LTE，联通FDD-LTE，或者说是FDD-LTE与TD-LTE融合；

联通3G：WCDMA；

联通2G：GSM。

3、**中国电信** 

电信4G：电信TD-LTE，电信FDD-LTE，或者说是FDD-LTE与TD-LTE融合；

电信3G：CDMA2000；

电信2G：CDMA

## 2、通信工程师的理解

通信工程师是指能在**通信领域中从事研究、设计、制造、运营**以及在国民经济各部门和国防工业中从事**开发、应用通信技术与设备的高级工程技术人才**。



## 3、对通信协议的理解

**通信协议是指双方实体完成通信或服务所必须遵循的规则和约定**。通过通信信道和设备互连起来的多个不同地理位置的数据通信系统，要使其能协同工作实现信息交换和资源共享，它们之间必须具有共同的语言。交流什么、怎样交流及何时交流，都必须遵循某种互相都能接受的规则。这个规则就是通信协议。



# 七、Spring

## 1、什么是Spring

Spring是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。



## 2、Spring的6个特征

- 核心技术：依赖注入（DI），AOP，事件（events），资源，i18n，验证，数据绑定，类型转换，SpEL。
- 测试：模拟对象，TestContext框架，Spring MVC测试，WebTestClient。
- 数据访问：事务，DAO支持，JDBC，ORM，编组XML
- Web支持：Spring MVC和Spring WebFlux Web框架
- 集成：远程处理，JMS，JCA，JMXX，电子邮件，任务，调度，缓存。
- 语言：Kotlin，Groovy，动态语言

## 3、spring的一些重要模块

- spring core：基础，可以说spring其他 所有的功能都需要依赖于该类库。主要提供IoC依赖注入功能。
- Spring Aspects：该模块为与AspectJ的集成提供支持
- Spring AOP：提供了面向切面的编程实现
- Spring JDBC： Java数据库连接
- Spring JMS： Java消息服务
- Spring ORM：用于支持Hibernate等ORM工具
- Spring Web：为创建Web应用程序提供支持
- Spring Test：提供了JUnit和TestNG测试的支持。



## 4、Spring IoC和AOP

==IOC==：

**IoC（Inverse of Control：控制反转）是一种设计思想，就是将原本在程序中手动创建对象的控制权，交给Spring框架来管理**。IoC容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map（key，value），Map中存放的是各种对象。**IoC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好文件/注解即可，完全不用考虑对象是如何被创建出来的**。

**Spring时代我们一般通过XML文件来配置Bean，后来开发人员觉得XML文件配置不太好，于是Spring Boot注解配置就慢慢开始流行起来了**。

==**AOP**==：

**AOP（Aspect-Oriented Programming：面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少重复的代码，降低模块间的耦合度，并利于未来的可扩展性和可维护性**。

**Spring AOP就是基于动态代理的**。**如果要代理的对象实现了某个接口，那么Spring AOP会使用JDK Proxy去创建代理对象，对于没有实现接口的对象，这时候Spring AOP会使用Cglib生成一个被代理的子类作为代理**。



## 5、Spring bean的作用域有哪些

- **singleton**：唯一bean实例，Spring中的bean默认都是单例的。
- **prototype**：每次请求都会创建一个新的bean实例
- **request**：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效
- **session**：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效
- **global-session**：全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与servlet不同，每个portlet都有不同的回话。



## 6、@Component和@Bean的区别是什么？

- **作用对象不同**：==@Component注解作用于类==，==而@Bean作用于方法==。
- **@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中**（我们可以使用@Component注解定义要扫描的路径从中找出标识了需要装配的类自动装配到Spring的bean容器中）。**@Bean注解通常是我们在标有该注解的方法中定义产生这个bean**，@Bean告诉了Spring这个某个类的实例，当我需要用它的时候还给我。
- **@Bean注解比@Component注解的自定义性更强**，**而且很多地方我们只能通过@Bean注解来注册bean**。比如当我们引用第三方库中的类需要装配Spring容器时，则只能通过@Bean来实现。

## 7、将一个类声明为Spring的bean的注解有哪些？

我们一般使用@Autowired注解自动装配bean，要想把类标识成可用于@Autowired注解自动装配的bean的类，采用以下注解可实现：

- **@Component**：通用注解，可标注任意类为Spring组件。如果一个Bean不知道术语哪个层，可以使用@Component注解标注
- **@Repository**：对应持久层即Dao层，主要用于数据库相关操作。
- **@Service**：对应服务层，主要涉及一些复杂的逻辑，需要用到Dao层。
- **@Controller**：对应Spring MVC控制层，主要用户接受用户请求并调用Service层返回数据给前端页面。

## 8、Spring框架中用到了哪些设计模式？

- **工厂设计模式**：Spring使用工厂模式通过BeanFactory、ApplicationContext创建bean对象.
- **代理设计模式**：Spring AOP功能的实现。
- **单例设计模式**：Spring中的Bean默认都是单例的。
- **包装器设计模式**：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式**：Spring事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式**：Spring AOP的增强或通知（Advice）使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配Controller。

## 9、Spring事务

Spring管理事务分为:

- 编程式事务,在代码中硬编码(不推荐使用)
- 声明式事务,在配置文件中配置(推荐使用)

声明式事务又分为两种:

- 基于XML的声明式事务
- 基于注解的声明式事务



# 八、Kafka

## 1、Kafka是什么？

Kafka是一个分布式流式处理平台。

**流平台具有三个关键功能**：

- **消息队列**：发布和订阅消息流，这个功能类似于消息队列，这也是Kafka被归类为消息队列的原因。
- **容错的持久方式存储记录消息流**：Kafka会把消息持久化到磁盘，有效避免了消息丢失的风险。
- **流式处理平台**：在消息发布的时候进行处理，Kafka提供了一个完整的流式处理类库。

**Kafka主要有两大应用场景**：

- **消息队列**：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据
- **数据处理**：构建实时的数据处理程序来转换或处理数据流

## 2、和其他的消息队列相比，Kafka的优势在哪

- **极致的性能**：基于Scala和Java语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。
- **生态系统兼容性无可匹敌**：Kafka与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。

## 3、早期的消息模型：队列模式

使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。



## 4、Kafka消息模型：发布-订阅模型

**发布订阅模型（Pub-Sub）使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者**，**在一条消息广播之后才订阅的用户则收不到该条消息**。

**在发布订阅模型中，如果只有一个订阅者，那它和队列模型久基本是一样的了。所以说，发布-订阅模型在功能层面上是可以兼容队列模型的**。

**RocketMQ的消息模型和Kafka基本是完全一样的。唯一的区别是Kafka中没有队列这个概念，与之对应的是Partition（分区）**。



## 5、什么是Producer、Consumer、Broker、Topic、Partition？

Kafka将生产者发布的消息发送到Topic（主题）中，需要这些消息的消费者可以订阅这些Topic（主题）。

- **Producer（生产者）**：产生消息的一方。
- **Consumer（消费者）**：消费消息的一方。
- **Broker（代理）**：可以看作是一个独立的Kafka实例。多个Kafka Broker组成一个Kafka Cluster

Broker中又包含了Topic以及Partition这两个重要的概念：

- **Topic（主题）**：Producer将消息发送到特定的主题，Consumer通过订阅特定的Topic（主题）来消费信息。
- **Partition（分区）**：Partition属于Topic的一部分。一个Topic可以有多个Partition，并且一个Topic下的Partition可以分布在不同的Broker上，这也就表明一个Topic可以横跨多个Broker。

**重点：Kafka中的Partition（分区）实际上可以对应称为消息队列中的队列**。











































